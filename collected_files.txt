//filename: ./xmake.lua
add_rules("mode.debug", "mode.release")

add_requires("glfw 3.4", "glm", "tinyobjloader", "stb")

target("VulkanApp")
    set_kind("binary")
    set_languages("c++17")

    add_files("src/*.cpp")
    add_packages("glfw", "glm", "tinyobjloader", "stb")

    add_links("vulkan")
    add_linkdirs("/usr/lib", "/usr/lib/x86_64-linux-gnu")
    add_includedirs("/usr/include", "src")

    add_defines("SHADER_DIR=\"shaders/\"")

    if is_mode("debug") then
        add_defines("DEBUG_BUILD")
    end

    before_build(function(target)
        local shaderdir = path.join(target:targetdir(), "shaders")
        os.mkdir(shaderdir)
        local shaders = {"phong.vert", "phong.frag"}
        for _, s in ipairs(shaders) do
            local src = path.join("shaders", s)
            local out = path.join(shaderdir, s:gsub("%.", "_") .. ".spv")
            if os.isfile(src) then
                os.execv("glslc", {src, "-o", out})
            end
        end
    end)

    after_build(function(target)
        if os.isdir("assets") then
            os.cp("assets", path.join(target:targetdir(), "assets"))
        end
    end)

//filename: ./src/Mesh.cpp
#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>
#include <unordered_map>
#include "Mesh.h"
#include <filesystem>
#include <stdexcept>
#include <iostream>
#include <fstream>
#include <sstream>

namespace fs = std::filesystem;

static std::string readFile(const std::string& path) {
    std::ifstream f(path);
    if (!f) throw std::runtime_error("cannot open: " + path);
    std::ostringstream ss;
    ss << f.rdbuf();
    return ss.str();
}

static std::string readFirstMtlName(const std::string& mtlText) {
    std::istringstream ss(mtlText);
    std::string line;
    while (std::getline(ss, line)) {
        if (line.rfind("newmtl", 0) == 0) {
            std::istringstream ls(line);
            std::string token, name;
            ls >> token >> name;
            return name;
        }
    }
    return {};
}

static std::string patchOBJ(const std::string& objText, const std::string& realMatName) {
    std::istringstream in(objText);
    std::ostringstream out;
    std::string line;
    while (std::getline(in, line)) {
        if (line.rfind("mtllib", 0) == 0);
        else if (line.rfind("usemtl", 0) == 0)
            out << "usemtl " << realMatName << "\n";
        else
            out << line << "\n";
    }
    return out.str();
}

std::vector<MeshData> loadOBJ(const std::string& path) {
    fs::path objDir = fs::path(path).parent_path();

    std::string mtlPath;
    for (auto& e : fs::directory_iterator(objDir))
        if (e.path().extension() == ".mtl") { mtlPath = e.path().string(); break; }

    tinyobj::ObjReaderConfig cfg;
    cfg.mtl_search_path = objDir.string();
    cfg.triangulate     = true;

    tinyobj::ObjReader reader;

    if (!mtlPath.empty()) {
        std::string mtlText     = readFile(mtlPath);
        std::string realMatName = readFirstMtlName(mtlText);
        std::string objText     = patchOBJ(readFile(path), realMatName);

        std::cout << "using mtl: " << mtlPath << "\n";
        std::cout << "patching usemtl -> '" << realMatName << "'\n";

        if (!reader.ParseFromString(objText, mtlText, cfg))
            throw std::runtime_error(reader.Error());
    } else {
        if (!reader.ParseFromFile(path, cfg))
            throw std::runtime_error(reader.Error());
    }

    if (!reader.Warning().empty())
        std::cerr << "[obj warning] " << reader.Warning() << "\n";

    auto& attrib    = reader.GetAttrib();
    auto& shapes    = reader.GetShapes();
    auto& materials = reader.GetMaterials();

    std::cout << "materials found: " << materials.size() << "\n";
    for (auto& mat : materials)
        std::cout << "  mat: '" << mat.name << "' tex: '" << mat.diffuse_texname << "'\n";

    std::unordered_map<int, MeshData> groups;

    for (auto& shape : shapes) {
        size_t offset = 0;
        for (size_t fi = 0; fi < shape.mesh.num_face_vertices.size(); fi++) {
            int fv    = shape.mesh.num_face_vertices[fi];
            int matId = shape.mesh.material_ids.empty() ? -1 : shape.mesh.material_ids[fi];

            MeshData& md = groups[matId];

            if (md.texturePath.empty() && matId >= 0 && matId < (int)materials.size()) {
                auto& tex = materials[matId].diffuse_texname;
                if (!tex.empty())
                    md.texturePath = objDir.string() + "/" + tex;
            }

            for (int v = 0; v < fv; v++) {
                auto idx = shape.mesh.indices[offset + v];
                Vertex vert{};

                vert.pos = {
                    attrib.vertices[3 * idx.vertex_index + 0],
                    attrib.vertices[3 * idx.vertex_index + 1],
                    attrib.vertices[3 * idx.vertex_index + 2],
                };

                if (idx.normal_index >= 0)
                    vert.normal = {
                        attrib.normals[3 * idx.normal_index + 0],
                        attrib.normals[3 * idx.normal_index + 1],
                        attrib.normals[3 * idx.normal_index + 2],
                    };

                if (idx.texcoord_index >= 0)
                    vert.uv = {
                        attrib.texcoords[2 * idx.texcoord_index + 0],
                        1.f - attrib.texcoords[2 * idx.texcoord_index + 1],
                    };

                md.indices.push_back(md.vertices.size());
                md.vertices.push_back(vert);
            }
            offset += fv;
        }
    }

    std::vector<MeshData> out;
    for (auto& [id, md] : groups) {
        if (md.vertices.empty() || md.indices.empty()) continue;
        std::cout << "  mesh group " << id << ": "
                  << md.vertices.size() << " verts, tex: "
                  << (md.texturePath.empty() ? "(none)" : md.texturePath) << "\n";
        out.push_back(std::move(md));
    }

    std::cout << "loaded " << path << " (" << out.size() << " meshes)\n";
    return out;
}

//filename: ./src/Renderer.h
#pragma once
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include "Types.h"
#include "Window.h"
#include <vector>
#include <array>
#include <optional>
#include <string>

class Renderer {
public:
    explicit Renderer(Window& window);
    ~Renderer();
    Renderer(const Renderer&) = delete;
    Renderer& operator=(const Renderer&) = delete;

    void uploadMesh(const MeshData& mesh);
    void clearMeshes();

    bool beginFrame();
    void draw(int meshIdx, const glm::mat4& model);
    void endFrame();

    void setCamera(glm::vec3 eye, glm::vec3 target, glm::vec3 up);
    void setLight(glm::vec3 pos, glm::vec3 color, float specPow = 64.f);
    void setUV(glm::vec2 offset, glm::vec2 scale);

    int meshCount() const { return (int)m_meshes.size(); }

private:
    struct QFI {
        std::optional<uint32_t> gfx, present;
        bool ok() const { return gfx && present; }
    };
    struct SCSupport {
        VkSurfaceCapabilitiesKHR caps{};
        std::vector<VkSurfaceFormatKHR> fmts;
        std::vector<VkPresentModeKHR>   modes;
    };
    struct GpuMesh {
        VkBuffer vb = VK_NULL_HANDLE, ib = VK_NULL_HANDLE;
        VkDeviceMemory vm = VK_NULL_HANDLE, im = VK_NULL_HANDLE;
        uint32_t count = 0;

        VkImage        texImg  = VK_NULL_HANDLE;
        VkDeviceMemory texMem  = VK_NULL_HANDLE;
        VkImageView    texView = VK_NULL_HANDLE;
        VkSampler      texSampler = VK_NULL_HANDLE;
        bool           hasTex  = false;

        std::array<VkDescriptorSet, 2> ds{};
    };

    static constexpr int FRAMES = 2;
    static constexpr int MAX_MESHES = 64;

    void initInstance();
    void initSurface();
    void initDevice();
    void initSwapchain();
    void initImageViews();
    void initRenderPass();
    void initDepth();
    void initFramebuffers();
    void initCmdPool();
    void initDescLayout();
    void initPipeline();
    void initWhiteTex();
    void initUBOs();
    void initDescPool();
    void initCmdBuffers();
    void initSync();

    void recreateSwapchain();
    void destroySwapchain();

    QFI       findQFI(VkPhysicalDevice);
    SCSupport querySC(VkPhysicalDevice);
    bool      deviceOk(VkPhysicalDevice);

    VkSurfaceFormatKHR pickFmt(const std::vector<VkSurfaceFormatKHR>&);
    VkPresentModeKHR   pickMode(const std::vector<VkPresentModeKHR>&);
    VkExtent2D         pickExtent(const VkSurfaceCapabilitiesKHR&);
    VkFormat           depthFmt();
    VkFormat           findFmt(const std::vector<VkFormat>&, VkImageTiling, VkFormatFeatureFlags);
    uint32_t           memType(uint32_t filter, VkMemoryPropertyFlags);
    VkShaderModule     makeShader(const std::vector<char>&);
    std::vector<char>  readFile(const std::string&);

    void mkBuf(VkDeviceSize, VkBufferUsageFlags, VkMemoryPropertyFlags, VkBuffer&, VkDeviceMemory&);
    void cpBuf(VkBuffer, VkBuffer, VkDeviceSize);
    void mkImg(uint32_t, uint32_t, VkFormat, VkImageTiling, VkImageUsageFlags, VkMemoryPropertyFlags, VkImage&, VkDeviceMemory&);
    VkImageView mkView(VkImage, VkFormat, VkImageAspectFlags);
    void transitionImg(VkImage, VkFormat, VkImageLayout, VkImageLayout);
    void cpBufToImg(VkBuffer, VkImage, uint32_t, uint32_t);
    VkCommandBuffer beginOnce();
    void            endOnce(VkCommandBuffer);

    void allocMeshDescSets(GpuMesh& gm);
    void writeMeshDescSets(GpuMesh& gm);
    void uploadTextureToMesh(GpuMesh& gm, const std::string& path);
    void updateUBO(uint32_t frame, const glm::mat4& model);

    Window& m_win;

    VkInstance               m_inst   = VK_NULL_HANDLE;
    VkDebugUtilsMessengerEXT m_dbg    = VK_NULL_HANDLE;
    VkSurfaceKHR             m_surf   = VK_NULL_HANDLE;
    VkPhysicalDevice         m_gpu    = VK_NULL_HANDLE;
    VkDevice                 m_dev    = VK_NULL_HANDLE;
    VkQueue                  m_gfxQ   = VK_NULL_HANDLE;
    VkQueue                  m_presQ  = VK_NULL_HANDLE;
    uint32_t                 m_gfxFam = 0;
    uint32_t                 m_presFam= 0;

    VkSwapchainKHR           m_sc     = VK_NULL_HANDLE;
    std::vector<VkImage>     m_scImgs;
    VkFormat                 m_scFmt  = VK_FORMAT_UNDEFINED;
    VkExtent2D               m_scExt  {};
    std::vector<VkImageView> m_scViews;

    VkRenderPass               m_rp   = VK_NULL_HANDLE;
    VkImage                    m_di   = VK_NULL_HANDLE;
    VkDeviceMemory             m_dm   = VK_NULL_HANDLE;
    VkImageView                m_dv   = VK_NULL_HANDLE;
    std::vector<VkFramebuffer> m_fbs;

    VkDescriptorSetLayout m_dsl  = VK_NULL_HANDLE;
    VkPipelineLayout      m_pl   = VK_NULL_HANDLE;
    VkPipeline            m_pipe = VK_NULL_HANDLE;

    VkCommandPool                m_cp = VK_NULL_HANDLE;
    std::vector<VkCommandBuffer> m_cmds;

    std::array<VkBuffer,       FRAMES> m_ub  {};
    std::array<VkDeviceMemory, FRAMES> m_ubm {};
    std::array<void*,          FRAMES> m_ubp {};

    VkDescriptorPool m_dp = VK_NULL_HANDLE;

    VkImage        m_wImg = VK_NULL_HANDLE;
    VkDeviceMemory m_wMem = VK_NULL_HANDLE;
    VkImageView    m_wV   = VK_NULL_HANDLE;
    VkSampler      m_wS   = VK_NULL_HANDLE;

    std::vector<GpuMesh> m_meshes;

    std::array<VkSemaphore, FRAMES> m_imgReady{};
    std::array<VkSemaphore, FRAMES> m_renDone{};
    std::array<VkFence,     FRAMES> m_fence{};

    UBO      m_ubo{};
    uint32_t m_frame  = 0;
    uint32_t m_imgIdx = 0;
    bool     m_recording = false;
    bool     m_validation = false;
};

//filename: ./src/main.cpp
#include "Window.h"
#include "Input.h"
#include "Timer.h"
#include "Renderer.h"
#include "Mesh.h"
#include <glm/gtc/matrix_transform.hpp>
#include <filesystem>
#include <iostream>
#include <string>
#include <cmath>

namespace fs = std::filesystem;

static std::string findOBJ() {
    if (!fs::exists("assets")) return {};
    for (auto& e : fs::directory_iterator("assets"))
        if (e.path().extension() == ".obj")
            return e.path().string();
    return {};
}

static std::string findTexture(const fs::path& dir) {
    for (auto& e : fs::directory_iterator(dir)) {
        auto ext = e.path().extension().string();
        if (ext == ".png" || ext == ".jpg" || ext == ".jpeg")
            return e.path().string();
    }
    return {};
}

int main() {
    std::string objPath = findOBJ();
    if (objPath.empty()) {
        std::cerr << "no .obj found in assets/\n";
        return 1;
    }

    Window   window(1280, 720, "VulkanApp");
    Input::get().init(window.handle());

    Renderer renderer(window);
    renderer.setLight({5, 8, 5}, {1, 1, 1}, 64.f);
    renderer.setUV({0, 0}, {1, 1});

    auto meshes = loadOBJ(objPath);
    if (meshes.empty()) {
        std::cerr << "failed to load " << objPath << "\n";
        return 1;
    }

    std::string fallbackTex = findTexture(fs::path(objPath).parent_path());
    if (!fallbackTex.empty())
        std::cout << "fallback texture: " << fallbackTex << "\n";

    for (auto& m : meshes) {
        if (m.texturePath.empty() && !fallbackTex.empty())
            m.texturePath = fallbackTex;
        renderer.uploadMesh(m);
    }

    glm::vec3 pos   = {0, 1, 3};
    float     yaw   = -90.f;
    float     pitch = -10.f;
    Timer     timer;

    int uvMode = 0;

    while (!window.shouldClose()) {
        Input::get().beginFrame();
        window.poll();
        timer.tick();

        float dt    = timer.dt();
        float total = timer.total();

        if (Input::get().isDown(GLFW_KEY_ESCAPE)) break;
        if (Input::get().pressed(GLFW_KEY_1)) uvMode = 0;
        if (Input::get().pressed(GLFW_KEY_2)) uvMode = 1;
        if (Input::get().pressed(GLFW_KEY_3)) uvMode = 2;

        switch (uvMode) {
            case 0:
                renderer.setUV({0.f, 0.f}, {1.f, 1.f});
                break;
            case 1:
                renderer.setUV({total * 0.1f, total * 0.05f}, {1.f, 1.f});
                break;
            case 2:
                renderer.setUV({0.f, 0.f}, {
                    1.f + 0.5f * sinf(total),
                    1.f + 0.5f * sinf(total)
                });
                break;
        }

        auto d = Input::get().delta();
        yaw   += d.x * 0.12f;
        pitch -= d.y * 0.12f;
        pitch  = glm::clamp(pitch, -89.f, 89.f);

        glm::vec3 dir = glm::normalize(glm::vec3(
            cos(glm::radians(yaw)) * cos(glm::radians(pitch)),
            sin(glm::radians(pitch)),
            sin(glm::radians(yaw)) * cos(glm::radians(pitch))
        ));
        glm::vec3 right = glm::normalize(glm::cross(dir, {0, 1, 0}));

        float speed = 5.f * dt;
        if (Input::get().isDown(GLFW_KEY_LEFT_SHIFT)) speed *= 3.f;
        if (Input::get().isDown(GLFW_KEY_W)) pos += dir   * speed;
        if (Input::get().isDown(GLFW_KEY_S)) pos -= dir   * speed;
        if (Input::get().isDown(GLFW_KEY_A)) pos -= right * speed;
        if (Input::get().isDown(GLFW_KEY_D)) pos += right * speed;
        if (Input::get().isDown(GLFW_KEY_SPACE))        pos.y += speed;
        if (Input::get().isDown(GLFW_KEY_LEFT_CONTROL)) pos.y -= speed;

        renderer.setCamera(pos, pos + dir, {0, 1, 0});

        if (!renderer.beginFrame()) continue;
        for (int i = 0; i < renderer.meshCount(); i++)
            renderer.draw(i, glm::mat4(1.f));
        renderer.endFrame();

        static float t = 0; t += dt;
        if (t > 0.5f) {
            t = 0;
            window.setTitle("VulkanApp | " + std::to_string(timer.fps()) +
                            " fps | UV mode: " + std::to_string(uvMode + 1));
        }
    }
}

//filename: ./src/Renderer.cpp
#include "Renderer.h"
#include <vulkan/vulkan_core.h>

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#include <glm/gtc/matrix_transform.hpp>
#include "Mesh.h"
#include <fstream>
#include <stdexcept>
#include <iostream>
#include <set>
#include <algorithm>
#include <cstring>
#include <filesystem>

static const std::vector<const char*> kDevExts = { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
static const std::vector<const char*> kLayers  = { "VK_LAYER_KHRONOS_validation" };

static VKAPI_ATTR VkBool32 VKAPI_CALL debugCb(
    VkDebugUtilsMessageSeverityFlagBitsEXT sev, VkDebugUtilsMessageTypeFlagsEXT,
    const VkDebugUtilsMessengerCallbackDataEXT* d, void*)
{
    if (sev >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)
        std::cerr << "[vk] " << d->pMessage << "\n";
    return VK_FALSE;
}

Renderer::Renderer(Window& window) : m_win(window) {
#ifndef NDEBUG
    m_validation = true;
#endif
    initInstance();
    initSurface();
    initDevice();
    initSwapchain();
    initImageViews();
    initRenderPass();
    initDepth();
    initFramebuffers();
    initCmdPool();
    initDescLayout();
    initPipeline();
    initWhiteTex();
    initUBOs();
    initDescPool();
    initCmdBuffers();
    initSync();

    m_ubo.lightPos   = glm::vec4(3, 5, 3, 0);
    m_ubo.lightColor = glm::vec4(1, 1, 1, 64);
    m_ubo.uvOffset   = glm::vec2(0, 0);
    m_ubo.uvScale    = glm::vec2(1, 1);
    setCamera({0, 1, 3}, {0, 0, 0}, {0, 1, 0});
}

Renderer::~Renderer() {
    vkDeviceWaitIdle(m_dev);
    destroySwapchain();

    clearMeshes();

    if (m_wS)   vkDestroySampler(m_dev, m_wS, nullptr);
    if (m_wV)   vkDestroyImageView(m_dev, m_wV, nullptr);
    if (m_wImg) vkDestroyImage(m_dev, m_wImg, nullptr);
    if (m_wMem) vkFreeMemory(m_dev, m_wMem, nullptr);

    for (int i = 0; i < FRAMES; ++i) {
        vkDestroyBuffer(m_dev, m_ub[i], nullptr);
        vkFreeMemory(m_dev, m_ubm[i], nullptr);
    }

    vkDestroyDescriptorPool(m_dev, m_dp, nullptr);
    vkDestroyDescriptorSetLayout(m_dev, m_dsl, nullptr);
    vkDestroyPipeline(m_dev, m_pipe, nullptr);
    vkDestroyPipelineLayout(m_dev, m_pl, nullptr);
    vkDestroyRenderPass(m_dev, m_rp, nullptr);
    vkDestroyCommandPool(m_dev, m_cp, nullptr);

    for (int i = 0; i < FRAMES; ++i) {
        vkDestroySemaphore(m_dev, m_imgReady[i], nullptr);
        vkDestroySemaphore(m_dev, m_renDone[i], nullptr);
        vkDestroyFence(m_dev, m_fence[i], nullptr);
    }

    vkDestroyDevice(m_dev, nullptr);

    if (m_dbg) {
        auto fn = (PFN_vkDestroyDebugUtilsMessengerEXT)
            vkGetInstanceProcAddr(m_inst, "vkDestroyDebugUtilsMessengerEXT");
        if (fn) fn(m_inst, m_dbg, nullptr);
    }

    vkDestroySurfaceKHR(m_inst, m_surf, nullptr);
    vkDestroyInstance(m_inst, nullptr);
}

void Renderer::initInstance() {
    if (m_validation) {
        uint32_t n = 0;
        vkEnumerateInstanceLayerProperties(&n, nullptr);
        std::vector<VkLayerProperties> layers(n);
        vkEnumerateInstanceLayerProperties(&n, layers.data());
        bool found = false;
        for (auto& l : layers)
            if (strcmp(l.layerName, "VK_LAYER_KHRONOS_validation") == 0) { found = true; break; }
        if (!found) m_validation = false;
    }

    VkApplicationInfo ai{};
    ai.sType      = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    ai.apiVersion = VK_API_VERSION_1_2;

    uint32_t n = 0;
    const char** exts = glfwGetRequiredInstanceExtensions(&n);
    std::vector<const char*> extensions(exts, exts + n);
    if (m_validation) extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);

    VkInstanceCreateInfo ci{};
    ci.sType                   = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    ci.pApplicationInfo        = &ai;
    ci.enabledExtensionCount   = extensions.size();
    ci.ppEnabledExtensionNames = extensions.data();
    if (m_validation) {
        ci.enabledLayerCount   = kLayers.size();
        ci.ppEnabledLayerNames = kLayers.data();
    }

    if (vkCreateInstance(&ci, nullptr, &m_inst) != VK_SUCCESS)
        throw std::runtime_error("vkCreateInstance failed");

    if (m_validation) {
        VkDebugUtilsMessengerCreateInfoEXT dci{};
        dci.sType           = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
        dci.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
                              VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
        dci.messageType     = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
                              VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
        dci.pfnUserCallback = debugCb;
        auto fn = (PFN_vkCreateDebugUtilsMessengerEXT)
            vkGetInstanceProcAddr(m_inst, "vkCreateDebugUtilsMessengerEXT");
        if (fn) fn(m_inst, &dci, nullptr, &m_dbg);
    }
}

void Renderer::initSurface() {
    if (glfwCreateWindowSurface(m_inst, m_win.handle(), nullptr, &m_surf) != VK_SUCCESS)
        throw std::runtime_error("glfwCreateWindowSurface failed");
}

void Renderer::initDevice() {
    uint32_t n = 0;
    vkEnumeratePhysicalDevices(m_inst, &n, nullptr);
    if (!n) throw std::runtime_error("no Vulkan GPU found");
    std::vector<VkPhysicalDevice> devs(n);
    vkEnumeratePhysicalDevices(m_inst, &n, devs.data());

    for (auto d : devs)
        if (deviceOk(d)) { m_gpu = d; break; }

    if (!m_gpu) throw std::runtime_error("no suitable GPU");

    auto qfi = findQFI(m_gpu);
    m_gfxFam  = qfi.gfx.value();
    m_presFam = qfi.present.value();

    std::set<uint32_t> fams = {m_gfxFam, m_presFam};
    float prio = 1.f;
    std::vector<VkDeviceQueueCreateInfo> qcis;
    for (uint32_t f : fams) {
        VkDeviceQueueCreateInfo q{};
        q.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        q.queueFamilyIndex = f;
        q.queueCount = 1;
        q.pQueuePriorities = &prio;
        qcis.push_back(q);
    }

    VkPhysicalDeviceFeatures feat{};
    feat.samplerAnisotropy = VK_TRUE;

    VkDeviceCreateInfo ci{};
    ci.sType                   = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    ci.queueCreateInfoCount    = qcis.size();
    ci.pQueueCreateInfos       = qcis.data();
    ci.enabledExtensionCount   = kDevExts.size();
    ci.ppEnabledExtensionNames = kDevExts.data();
    ci.pEnabledFeatures        = &feat;

    if (m_validation) {
        ci.enabledLayerCount   = kLayers.size();
        ci.ppEnabledLayerNames = kLayers.data();
    }

    if (vkCreateDevice(m_gpu, &ci, nullptr, &m_dev) != VK_SUCCESS)
        throw std::runtime_error("vkCreateDevice failed");

    vkGetDeviceQueue(m_dev, m_gfxFam, 0, &m_gfxQ);
    vkGetDeviceQueue(m_dev, m_presFam, 0, &m_presQ);

    VkPhysicalDeviceProperties props;
    vkGetPhysicalDeviceProperties(m_gpu, &props);
    std::cout << "gpu: " << props.deviceName << "\n";
}

void Renderer::initSwapchain() {
    auto sc  = querySC(m_gpu);
    auto fmt = pickFmt(sc.fmts);
    auto mode= pickMode(sc.modes);
    auto ext = pickExtent(sc.caps);

    uint32_t count = sc.caps.minImageCount + 1;
    if (sc.caps.maxImageCount > 0)
        count = std::min(count, sc.caps.maxImageCount);

    VkSwapchainCreateInfoKHR ci{};
    ci.sType           = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    ci.surface         = m_surf;
    ci.minImageCount   = count;
    ci.imageFormat     = fmt.format;
    ci.imageColorSpace = fmt.colorSpace;
    ci.imageExtent     = ext;
    ci.imageArrayLayers= 1;
    ci.imageUsage      = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

    uint32_t fams[] = {m_gfxFam, m_presFam};
    if (m_gfxFam != m_presFam) {
        ci.imageSharingMode      = VK_SHARING_MODE_CONCURRENT;
        ci.queueFamilyIndexCount = 2;
        ci.pQueueFamilyIndices   = fams;
    } else {
        ci.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    }

    ci.preTransform   = sc.caps.currentTransform;
    ci.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    ci.presentMode    = mode;
    ci.clipped        = VK_TRUE;

    if (vkCreateSwapchainKHR(m_dev, &ci, nullptr, &m_sc) != VK_SUCCESS)
        throw std::runtime_error("vkCreateSwapchainKHR failed");

    vkGetSwapchainImagesKHR(m_dev, m_sc, &count, nullptr);
    m_scImgs.resize(count);
    vkGetSwapchainImagesKHR(m_dev, m_sc, &count, m_scImgs.data());
    m_scFmt = fmt.format;
    m_scExt = ext;
}

void Renderer::initImageViews() {
    m_scViews.resize(m_scImgs.size());
    for (size_t i = 0; i < m_scImgs.size(); ++i)
        m_scViews[i] = mkView(m_scImgs[i], m_scFmt, VK_IMAGE_ASPECT_COLOR_BIT);
}

void Renderer::initRenderPass() {
    VkAttachmentDescription col{};
    col.format         = m_scFmt;
    col.samples        = VK_SAMPLE_COUNT_1_BIT;
    col.loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;
    col.storeOp        = VK_ATTACHMENT_STORE_OP_STORE;
    col.stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    col.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    col.initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;
    col.finalLayout    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentDescription dep{};
    dep.format         = depthFmt();
    dep.samples        = VK_SAMPLE_COUNT_1_BIT;
    dep.loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;
    dep.storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    dep.stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    dep.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    dep.initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;
    dep.finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkAttachmentReference colRef{0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};
    VkAttachmentReference depRef{1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};

    VkSubpassDescription sub{};
    sub.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;
    sub.colorAttachmentCount    = 1;
    sub.pColorAttachments       = &colRef;
    sub.pDepthStencilAttachment = &depRef;

    VkSubpassDependency d{};
    d.srcSubpass    = VK_SUBPASS_EXTERNAL;
    d.dstSubpass    = 0;
    d.srcStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
                      VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    d.dstStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
                      VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    d.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
                      VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    std::array<VkAttachmentDescription, 2> atts = {col, dep};
    VkRenderPassCreateInfo ci{};
    ci.sType           = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    ci.attachmentCount = atts.size();
    ci.pAttachments    = atts.data();
    ci.subpassCount    = 1;
    ci.pSubpasses      = &sub;
    ci.dependencyCount = 1;
    ci.pDependencies   = &d;

    if (vkCreateRenderPass(m_dev, &ci, nullptr, &m_rp) != VK_SUCCESS)
        throw std::runtime_error("vkCreateRenderPass failed");
}

void Renderer::initDepth() {
    auto fmt = depthFmt();
    mkImg(m_scExt.width, m_scExt.height, fmt, VK_IMAGE_TILING_OPTIMAL,
          VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
          VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, m_di, m_dm);
    m_dv = mkView(m_di, fmt, VK_IMAGE_ASPECT_DEPTH_BIT);
}

void Renderer::initFramebuffers() {
    m_fbs.resize(m_scViews.size());
    for (size_t i = 0; i < m_scViews.size(); ++i) {
        std::array<VkImageView, 2> atts = {m_scViews[i], m_dv};
        VkFramebufferCreateInfo fi{};
        fi.sType           = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        fi.renderPass      = m_rp;
        fi.attachmentCount = atts.size();
        fi.pAttachments    = atts.data();
        fi.width           = m_scExt.width;
        fi.height          = m_scExt.height;
        fi.layers          = 1;
        vkCreateFramebuffer(m_dev, &fi, nullptr, &m_fbs[i]);
    }
}

void Renderer::initCmdPool() {
    VkCommandPoolCreateInfo ci{};
    ci.sType            = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    ci.flags            = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    ci.queueFamilyIndex = m_gfxFam;
    vkCreateCommandPool(m_dev, &ci, nullptr, &m_cp);
}

void Renderer::initDescLayout() {
    VkDescriptorSetLayoutBinding ubo{};
    ubo.binding         = 0;
    ubo.descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    ubo.descriptorCount = 1;
    ubo.stageFlags      = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;

    VkDescriptorSetLayoutBinding tex{};
    tex.binding         = 1;
    tex.descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    tex.descriptorCount = 1;
    tex.stageFlags      = VK_SHADER_STAGE_FRAGMENT_BIT;

    std::array<VkDescriptorSetLayoutBinding, 2> bindings = {ubo, tex};
    VkDescriptorSetLayoutCreateInfo ci{};
    ci.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    ci.bindingCount = bindings.size();
    ci.pBindings    = bindings.data();
    vkCreateDescriptorSetLayout(m_dev, &ci, nullptr, &m_dsl);
}

void Renderer::initPipeline() {
    auto vert = makeShader(readFile(SHADER_DIR "phong_vert.spv"));
    auto frag = makeShader(readFile(SHADER_DIR "phong_frag.spv"));

    VkPipelineShaderStageCreateInfo stages[2]{};
    stages[0].sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    stages[0].stage  = VK_SHADER_STAGE_VERTEX_BIT;
    stages[0].module = vert;
    stages[0].pName  = "main";
    stages[1].sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    stages[1].stage  = VK_SHADER_STAGE_FRAGMENT_BIT;
    stages[1].module = frag;
    stages[1].pName  = "main";

    auto bd = Vertex::binding();
    auto ad = Vertex::attrs();
    VkPipelineVertexInputStateCreateInfo vi{};
    vi.sType                           = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vi.vertexBindingDescriptionCount   = 1;
    vi.pVertexBindingDescriptions      = &bd;
    vi.vertexAttributeDescriptionCount = ad.size();
    vi.pVertexAttributeDescriptions    = ad.data();

    VkPipelineInputAssemblyStateCreateInfo ia{};
    ia.sType    = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    ia.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;

    VkPipelineViewportStateCreateInfo vp{};
    vp.sType         = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    vp.viewportCount = 1;
    vp.scissorCount  = 1;

    std::vector<VkDynamicState> dynStates = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
    VkPipelineDynamicStateCreateInfo dyn{};
    dyn.sType             = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dyn.dynamicStateCount = dynStates.size();
    dyn.pDynamicStates    = dynStates.data();

    VkPipelineRasterizationStateCreateInfo rs{};
    rs.sType       = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rs.polygonMode = VK_POLYGON_MODE_FILL;
    rs.cullMode    = VK_CULL_MODE_BACK_BIT;
    rs.frontFace   = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rs.lineWidth   = 1.f;

    VkPipelineMultisampleStateCreateInfo ms{};
    ms.sType                = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    ms.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineDepthStencilStateCreateInfo ds{};
    ds.sType            = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    ds.depthTestEnable  = VK_TRUE;
    ds.depthWriteEnable = VK_TRUE;
    ds.depthCompareOp   = VK_COMPARE_OP_LESS;

    VkPipelineColorBlendAttachmentState cba{};
    cba.colorWriteMask = VK_COLOR_COMPONENT_R_BIT|VK_COLOR_COMPONENT_G_BIT|
                         VK_COLOR_COMPONENT_B_BIT|VK_COLOR_COMPONENT_A_BIT;

    VkPipelineColorBlendStateCreateInfo cb{};
    cb.sType           = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    cb.attachmentCount = 1;
    cb.pAttachments    = &cba;

    VkPipelineLayoutCreateInfo pli{};
    pli.sType          = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pli.setLayoutCount = 1;
    pli.pSetLayouts    = &m_dsl;
    vkCreatePipelineLayout(m_dev, &pli, nullptr, &m_pl);

    VkGraphicsPipelineCreateInfo pci{};
    pci.sType               = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pci.stageCount          = 2;
    pci.pStages             = stages;
    pci.pVertexInputState   = &vi;
    pci.pInputAssemblyState = &ia;
    pci.pViewportState      = &vp;
    pci.pRasterizationState = &rs;
    pci.pMultisampleState   = &ms;
    pci.pDepthStencilState  = &ds;
    pci.pColorBlendState    = &cb;
    pci.pDynamicState       = &dyn;
    pci.layout              = m_pl;
    pci.renderPass          = m_rp;

    if (vkCreateGraphicsPipelines(m_dev, VK_NULL_HANDLE, 1, &pci, nullptr, &m_pipe) != VK_SUCCESS)
        throw std::runtime_error("vkCreateGraphicsPipelines failed");

    vkDestroyShaderModule(m_dev, vert, nullptr);
    vkDestroyShaderModule(m_dev, frag, nullptr);
}

void Renderer::initWhiteTex() {
    uint8_t px[4] = {255, 255, 255, 255};
    VkBuffer sb; VkDeviceMemory sm;
    mkBuf(4, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
          VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, sb, sm);
    void* p; vkMapMemory(m_dev, sm, 0, 4, 0, &p);
    memcpy(p, px, 4);
    vkUnmapMemory(m_dev, sm);

    mkImg(1, 1, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL,
          VK_IMAGE_USAGE_TRANSFER_DST_BIT|VK_IMAGE_USAGE_SAMPLED_BIT,
          VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, m_wImg, m_wMem);
    transitionImg(m_wImg, VK_FORMAT_R8G8B8A8_SRGB,
                  VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
    cpBufToImg(sb, m_wImg, 1, 1);
    transitionImg(m_wImg, VK_FORMAT_R8G8B8A8_SRGB,
                  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
    vkDestroyBuffer(m_dev, sb, nullptr);
    vkFreeMemory(m_dev, sm, nullptr);

    m_wV = mkView(m_wImg, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);

    VkSamplerCreateInfo si{};
    si.sType        = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    si.magFilter    = VK_FILTER_LINEAR;
    si.minFilter    = VK_FILTER_LINEAR;
    si.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    si.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    si.anisotropyEnable = VK_TRUE;
    si.maxAnisotropy    = 16.f;
    si.mipmapMode   = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    vkCreateSampler(m_dev, &si, nullptr, &m_wS);
}

void Renderer::initUBOs() {
    for (int i = 0; i < FRAMES; ++i) {
        mkBuf(sizeof(UBO), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
              VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
              m_ub[i], m_ubm[i]);
        vkMapMemory(m_dev, m_ubm[i], 0, sizeof(UBO), 0, &m_ubp[i]);
    }
}

void Renderer::initDescPool() {
    std::array<VkDescriptorPoolSize, 2> sz = {{
        {VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,         MAX_MESHES * FRAMES},
        {VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, MAX_MESHES * FRAMES},
    }};

    VkDescriptorPoolCreateInfo ci{};
    ci.sType         = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    ci.poolSizeCount = sz.size();
    ci.pPoolSizes    = sz.data();
    ci.maxSets       = MAX_MESHES * FRAMES;
    vkCreateDescriptorPool(m_dev, &ci, nullptr, &m_dp);
}

void Renderer::initCmdBuffers() {
    m_cmds.resize(FRAMES);
    VkCommandBufferAllocateInfo ai{};
    ai.sType              = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    ai.commandPool        = m_cp;
    ai.level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    ai.commandBufferCount = FRAMES;
    vkAllocateCommandBuffers(m_dev, &ai, m_cmds.data());
}

void Renderer::initSync() {
    VkSemaphoreCreateInfo si{VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};
    VkFenceCreateInfo     fi{VK_STRUCTURE_TYPE_FENCE_CREATE_INFO};
    fi.flags = VK_FENCE_CREATE_SIGNALED_BIT;
    for (int i = 0; i < FRAMES; ++i) {
        vkCreateSemaphore(m_dev, &si, nullptr, &m_imgReady[i]);
        vkCreateSemaphore(m_dev, &si, nullptr, &m_renDone[i]);
        vkCreateFence(m_dev, &fi, nullptr, &m_fence[i]);
    }
}

void Renderer::allocMeshDescSets(GpuMesh& gm) {
    std::vector<VkDescriptorSetLayout> layouts(FRAMES, m_dsl);
    VkDescriptorSetAllocateInfo ai{};
    ai.sType              = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    ai.descriptorPool     = m_dp;
    ai.descriptorSetCount = FRAMES;
    ai.pSetLayouts        = layouts.data();
    vkAllocateDescriptorSets(m_dev, &ai, gm.ds.data());
}

void Renderer::writeMeshDescSets(GpuMesh& gm) {
    VkImageView  iv = gm.hasTex ? gm.texView    : m_wV;
    VkSampler    is = gm.hasTex ? gm.texSampler : m_wS;

    for (int i = 0; i < FRAMES; ++i) {
        VkDescriptorBufferInfo bi{m_ub[i], 0, sizeof(UBO)};
        VkDescriptorImageInfo  ii{is, iv, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};

        std::array<VkWriteDescriptorSet, 2> w{};
        w[0].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        w[0].dstSet          = gm.ds[i];
        w[0].dstBinding      = 0;
        w[0].descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        w[0].descriptorCount = 1;
        w[0].pBufferInfo     = &bi;

        w[1].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        w[1].dstSet          = gm.ds[i];
        w[1].dstBinding      = 1;
        w[1].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        w[1].descriptorCount = 1;
        w[1].pImageInfo      = &ii;

        vkUpdateDescriptorSets(m_dev, w.size(), w.data(), 0, nullptr);
    }
}

// Загружаем текстуру в конкретный меш
void Renderer::uploadTextureToMesh(GpuMesh& gm, const std::string& path) {
    int w, h, ch;
    stbi_uc* px = stbi_load(path.c_str(), &w, &h, &ch, STBI_rgb_alpha);
    if (!px) {
        std::cerr << "failed to load texture: " << path << "\n";
        return;
    }
    std::cout << "loaded texture: " << path << "\n";

    VkDeviceSize sz = w * h * 4;
    VkBuffer sb; VkDeviceMemory sm;
    mkBuf(sz, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
          VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, sb, sm);
    void* p; vkMapMemory(m_dev, sm, 0, sz, 0, &p);
    memcpy(p, px, sz);
    vkUnmapMemory(m_dev, sm);
    stbi_image_free(px);

    mkImg(w, h, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL,
          VK_IMAGE_USAGE_TRANSFER_DST_BIT|VK_IMAGE_USAGE_SAMPLED_BIT,
          VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, gm.texImg, gm.texMem);
    transitionImg(gm.texImg, VK_FORMAT_R8G8B8A8_SRGB,
                  VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
    cpBufToImg(sb, gm.texImg, w, h);
    transitionImg(gm.texImg, VK_FORMAT_R8G8B8A8_SRGB,
                  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
    vkDestroyBuffer(m_dev, sb, nullptr);
    vkFreeMemory(m_dev, sm, nullptr);

    gm.texView = mkView(gm.texImg, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);

    VkSamplerCreateInfo si{};
    si.sType            = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    si.magFilter        = VK_FILTER_LINEAR;
    si.minFilter        = VK_FILTER_LINEAR;
    si.addressModeU     = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    si.addressModeV     = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    si.anisotropyEnable = VK_TRUE;
    si.maxAnisotropy    = 16.f;
    si.mipmapMode       = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    vkCreateSampler(m_dev, &si, nullptr, &gm.texSampler);

    gm.hasTex = true;
}

void Renderer::uploadMesh(const MeshData& mesh) {
    GpuMesh gm;
    gm.count = mesh.indices.size();

    auto upload = [&](const void* data, VkDeviceSize sz, VkBufferUsageFlags usage,
                      VkBuffer& buf, VkDeviceMemory& mem) {
        VkBuffer sb; VkDeviceMemory sm;
        mkBuf(sz, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
              VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, sb, sm);
        void* p; vkMapMemory(m_dev, sm, 0, sz, 0, &p);
        memcpy(p, data, sz);
        vkUnmapMemory(m_dev, sm);
        mkBuf(sz, VK_BUFFER_USAGE_TRANSFER_DST_BIT|usage,
              VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, buf, mem);
        cpBuf(sb, buf, sz);
        vkDestroyBuffer(m_dev, sb, nullptr);
        vkFreeMemory(m_dev, sm, nullptr);
    };

    upload(mesh.vertices.data(), sizeof(Vertex)*mesh.vertices.size(),
           VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, gm.vb, gm.vm);
    upload(mesh.indices.data(), sizeof(uint32_t)*mesh.indices.size(),
           VK_BUFFER_USAGE_INDEX_BUFFER_BIT, gm.ib, gm.im);

    if (!mesh.texturePath.empty() && std::filesystem::exists(mesh.texturePath))
        uploadTextureToMesh(gm, mesh.texturePath);

    allocMeshDescSets(gm);
    writeMeshDescSets(gm);

    m_meshes.push_back(std::move(gm));
}

void Renderer::clearMeshes() {
    vkDeviceWaitIdle(m_dev);
    for (auto& gm : m_meshes) {
        vkDestroyBuffer(m_dev, gm.vb, nullptr); vkFreeMemory(m_dev, gm.vm, nullptr);
        vkDestroyBuffer(m_dev, gm.ib, nullptr); vkFreeMemory(m_dev, gm.im, nullptr);
        if (gm.hasTex) {
            vkDestroySampler(m_dev, gm.texSampler, nullptr);
            vkDestroyImageView(m_dev, gm.texView, nullptr);
            vkDestroyImage(m_dev, gm.texImg, nullptr);
            vkFreeMemory(m_dev, gm.texMem, nullptr);
        }
    }
    m_meshes.clear();
}

bool Renderer::beginFrame() {
    vkWaitForFences(m_dev, 1, &m_fence[m_frame], VK_TRUE, UINT64_MAX);

    VkResult r = vkAcquireNextImageKHR(m_dev, m_sc, UINT64_MAX,
                                        m_imgReady[m_frame], VK_NULL_HANDLE, &m_imgIdx);
    if (r == VK_ERROR_OUT_OF_DATE_KHR) { recreateSwapchain(); return false; }

    vkResetFences(m_dev, 1, &m_fence[m_frame]);

    auto cmd = m_cmds[m_frame];
    vkResetCommandBuffer(cmd, 0);
    VkCommandBufferBeginInfo bi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
    vkBeginCommandBuffer(cmd, &bi);

    std::array<VkClearValue, 2> clear{};
    clear[0].color        = {{0.05f, 0.05f, 0.05f, 1.f}};
    clear[1].depthStencil = {1.f, 0};

    VkRenderPassBeginInfo rpi{};
    rpi.sType             = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpi.renderPass        = m_rp;
    rpi.framebuffer       = m_fbs[m_imgIdx];
    rpi.renderArea.extent = m_scExt;
    rpi.clearValueCount   = clear.size();
    rpi.pClearValues      = clear.data();
    vkCmdBeginRenderPass(cmd, &rpi, VK_SUBPASS_CONTENTS_INLINE);

    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipe);

    VkViewport vp{0, 0, (float)m_scExt.width, (float)m_scExt.height, 0, 1};
    vkCmdSetViewport(cmd, 0, 1, &vp);
    VkRect2D sc{{0,0}, m_scExt};
    vkCmdSetScissor(cmd, 0, 1, &sc);

    m_recording = true;
    return true;
}

void Renderer::draw(int idx, const glm::mat4& model) {
    if (!m_recording || idx < 0 || idx >= (int)m_meshes.size()) return;
    updateUBO(m_frame, model);

    auto& gm  = m_meshes[idx];
    auto  cmd = m_cmds[m_frame];

    vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                             m_pl, 0, 1, &gm.ds[m_frame], 0, nullptr);

    VkDeviceSize off = 0;
    vkCmdBindVertexBuffers(cmd, 0, 1, &gm.vb, &off);
    vkCmdBindIndexBuffer(cmd, gm.ib, 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(cmd, gm.count, 1, 0, 0, 0);
}

void Renderer::endFrame() {
    if (!m_recording) return;
    m_recording = false;

    auto cmd = m_cmds[m_frame];
    vkCmdEndRenderPass(cmd);
    vkEndCommandBuffer(cmd);

    VkPipelineStageFlags wait = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    VkSubmitInfo si{};
    si.sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    si.waitSemaphoreCount   = 1;
    si.pWaitSemaphores      = &m_imgReady[m_frame];
    si.pWaitDstStageMask    = &wait;
    si.commandBufferCount   = 1;
    si.pCommandBuffers      = &cmd;
    si.signalSemaphoreCount = 1;
    si.pSignalSemaphores    = &m_renDone[m_frame];
    vkQueueSubmit(m_gfxQ, 1, &si, m_fence[m_frame]);

    VkPresentInfoKHR pi{};
    pi.sType              = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    pi.waitSemaphoreCount = 1;
    pi.pWaitSemaphores    = &m_renDone[m_frame];
    pi.swapchainCount     = 1;
    pi.pSwapchains        = &m_sc;
    pi.pImageIndices      = &m_imgIdx;

    VkResult r = vkQueuePresentKHR(m_presQ, &pi);
    if (r == VK_ERROR_OUT_OF_DATE_KHR || r == VK_SUBOPTIMAL_KHR || m_win.resized()) {
        m_win.clearResize();
        recreateSwapchain();
    }

    m_frame = (m_frame + 1) % FRAMES;
}

void Renderer::setCamera(glm::vec3 eye, glm::vec3 target, glm::vec3 up) {
    m_ubo.view    = glm::lookAt(eye, target, up);
    m_ubo.viewPos = glm::vec4(eye, 0);
}

void Renderer::setLight(glm::vec3 pos, glm::vec3 color, float specPow) {
    m_ubo.lightPos   = glm::vec4(pos, 0);
    m_ubo.lightColor = glm::vec4(color, specPow);
}

void Renderer::setUV(glm::vec2 offset, glm::vec2 scale) {
    m_ubo.uvOffset = offset;
    m_ubo.uvScale  = scale;
}

void Renderer::updateUBO(uint32_t frame, const glm::mat4& model) {
    m_ubo.model = model;
    m_ubo.proj  = glm::perspective(glm::radians(90.f), m_win.aspect(), 0.01f, 1000.f);
    m_ubo.proj[1][1] *= -1;
    memcpy(m_ubp[frame], &m_ubo, sizeof(m_ubo));
}

void Renderer::destroySwapchain() {
    vkDestroyImageView(m_dev, m_dv, nullptr);
    vkDestroyImage(m_dev, m_di, nullptr);
    vkFreeMemory(m_dev, m_dm, nullptr);
    for (auto fb : m_fbs) vkDestroyFramebuffer(m_dev, fb, nullptr);
    for (auto iv : m_scViews) vkDestroyImageView(m_dev, iv, nullptr);
    vkDestroySwapchainKHR(m_dev, m_sc, nullptr);
    m_fbs.clear(); m_scViews.clear(); m_scImgs.clear();
}

void Renderer::recreateSwapchain() {
    int w = 0, h = 0;
    while (!w || !h) { glfwGetFramebufferSize(m_win.handle(), &w, &h); glfwWaitEvents(); }
    vkDeviceWaitIdle(m_dev);
    destroySwapchain();
    initSwapchain(); initImageViews(); initDepth(); initFramebuffers();
}

Renderer::QFI Renderer::findQFI(VkPhysicalDevice dev) {
    QFI qi;
    uint32_t n; vkGetPhysicalDeviceQueueFamilyProperties(dev, &n, nullptr);
    std::vector<VkQueueFamilyProperties> fams(n);
    vkGetPhysicalDeviceQueueFamilyProperties(dev, &n, fams.data());
    for (uint32_t i = 0; i < n; ++i) {
        if (fams[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) qi.gfx = i;
        VkBool32 ps = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(dev, i, m_surf, &ps);
        if (ps) qi.present = i;
        if (qi.ok()) break;
    }
    return qi;
}

Renderer::SCSupport Renderer::querySC(VkPhysicalDevice dev) {
    SCSupport s;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(dev, m_surf, &s.caps);
    uint32_t n;
    vkGetPhysicalDeviceSurfaceFormatsKHR(dev, m_surf, &n, nullptr);
    s.fmts.resize(n); vkGetPhysicalDeviceSurfaceFormatsKHR(dev, m_surf, &n, s.fmts.data());
    vkGetPhysicalDeviceSurfacePresentModesKHR(dev, m_surf, &n, nullptr);
    s.modes.resize(n); vkGetPhysicalDeviceSurfacePresentModesKHR(dev, m_surf, &n, s.modes.data());
    return s;
}

bool Renderer::deviceOk(VkPhysicalDevice dev) {
    if (!findQFI(dev).ok()) return false;
    uint32_t n; vkEnumerateDeviceExtensionProperties(dev, nullptr, &n, nullptr);
    std::vector<VkExtensionProperties> exts(n);
    vkEnumerateDeviceExtensionProperties(dev, nullptr, &n, exts.data());
    for (auto& req : kDevExts) {
        bool found = false;
        for (auto& e : exts) if (!strcmp(e.extensionName, req)) { found = true; break; }
        if (!found) return false;
    }
    auto sc = querySC(dev);
    if (sc.fmts.empty() || sc.modes.empty()) return false;
    VkPhysicalDeviceFeatures f; vkGetPhysicalDeviceFeatures(dev, &f);
    return f.samplerAnisotropy;
}

VkSurfaceFormatKHR Renderer::pickFmt(const std::vector<VkSurfaceFormatKHR>& fmts) {
    for (auto& f : fmts)
        if (f.format == VK_FORMAT_B8G8R8A8_SRGB && f.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
            return f;
    return fmts[0];
}

VkPresentModeKHR Renderer::pickMode(const std::vector<VkPresentModeKHR>& modes) {
    for (auto m : modes) if (m == VK_PRESENT_MODE_MAILBOX_KHR) return m;
    return VK_PRESENT_MODE_FIFO_KHR;
}

VkExtent2D Renderer::pickExtent(const VkSurfaceCapabilitiesKHR& caps) {
    if (caps.currentExtent.width != UINT32_MAX) return caps.currentExtent;
    int w, h; glfwGetFramebufferSize(m_win.handle(), &w, &h);
    return {
        std::clamp((uint32_t)w, caps.minImageExtent.width,  caps.maxImageExtent.width),
        std::clamp((uint32_t)h, caps.minImageExtent.height, caps.maxImageExtent.height),
    };
}

VkFormat Renderer::depthFmt() {
    return findFmt({VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT},
                   VK_IMAGE_TILING_OPTIMAL, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);
}

VkFormat Renderer::findFmt(const std::vector<VkFormat>& cands, VkImageTiling tiling, VkFormatFeatureFlags feat) {
    for (auto f : cands) {
        VkFormatProperties p; vkGetPhysicalDeviceFormatProperties(m_gpu, f, &p);
        if (tiling == VK_IMAGE_TILING_OPTIMAL && (p.optimalTilingFeatures & feat) == feat) return f;
    }
    throw std::runtime_error("no supported format");
}

uint32_t Renderer::memType(uint32_t filter, VkMemoryPropertyFlags props) {
    VkPhysicalDeviceMemoryProperties mp; vkGetPhysicalDeviceMemoryProperties(m_gpu, &mp);
    for (uint32_t i = 0; i < mp.memoryTypeCount; ++i)
        if ((filter & (1<<i)) && (mp.memoryTypes[i].propertyFlags & props) == props) return i;
    throw std::runtime_error("no suitable memory type");
}

VkShaderModule Renderer::makeShader(const std::vector<char>& code) {
    VkShaderModuleCreateInfo ci{};
    ci.sType    = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    ci.codeSize = code.size();
    ci.pCode    = reinterpret_cast<const uint32_t*>(code.data());
    VkShaderModule m;
    if (vkCreateShaderModule(m_dev, &ci, nullptr, &m) != VK_SUCCESS)
        throw std::runtime_error("vkCreateShaderModule failed");
    return m;
}

std::vector<char> Renderer::readFile(const std::string& path) {
    std::ifstream f(path, std::ios::ate|std::ios::binary);
    if (!f) throw std::runtime_error("cannot open: " + path);
    size_t sz = f.tellg();
    std::vector<char> buf(sz);
    f.seekg(0); f.read(buf.data(), sz);
    return buf;
}

void Renderer::mkBuf(VkDeviceSize sz, VkBufferUsageFlags usage, VkMemoryPropertyFlags props,
                     VkBuffer& buf, VkDeviceMemory& mem) {
    VkBufferCreateInfo ci{VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO};
    ci.size = sz; ci.usage = usage; ci.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    vkCreateBuffer(m_dev, &ci, nullptr, &buf);
    VkMemoryRequirements req; vkGetBufferMemoryRequirements(m_dev, buf, &req);
    VkMemoryAllocateInfo ai{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO};
    ai.allocationSize = req.size; ai.memoryTypeIndex = memType(req.memoryTypeBits, props);
    vkAllocateMemory(m_dev, &ai, nullptr, &mem);
    vkBindBufferMemory(m_dev, buf, mem, 0);
}

void Renderer::cpBuf(VkBuffer src, VkBuffer dst, VkDeviceSize sz) {
    auto cmd = beginOnce();
    VkBufferCopy c{0, 0, sz};
    vkCmdCopyBuffer(cmd, src, dst, 1, &c);
    endOnce(cmd);
}

void Renderer::mkImg(uint32_t w, uint32_t h, VkFormat fmt, VkImageTiling tiling,
                     VkImageUsageFlags usage, VkMemoryPropertyFlags props,
                     VkImage& img, VkDeviceMemory& mem) {
    VkImageCreateInfo ci{VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO};
    ci.imageType = VK_IMAGE_TYPE_2D; ci.format = fmt; ci.extent = {w,h,1};
    ci.mipLevels = 1; ci.arrayLayers = 1; ci.samples = VK_SAMPLE_COUNT_1_BIT;
    ci.tiling = tiling; ci.usage = usage; ci.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    vkCreateImage(m_dev, &ci, nullptr, &img);
    VkMemoryRequirements req; vkGetImageMemoryRequirements(m_dev, img, &req);
    VkMemoryAllocateInfo ai{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO};
    ai.allocationSize = req.size; ai.memoryTypeIndex = memType(req.memoryTypeBits, props);
    vkAllocateMemory(m_dev, &ai, nullptr, &mem);
    vkBindImageMemory(m_dev, img, mem, 0);
}

VkImageView Renderer::mkView(VkImage img, VkFormat fmt, VkImageAspectFlags aspect) {
    VkImageViewCreateInfo ci{VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
    ci.image = img; ci.viewType = VK_IMAGE_VIEW_TYPE_2D; ci.format = fmt;
    ci.subresourceRange = {aspect, 0, 1, 0, 1};
    VkImageView v; vkCreateImageView(m_dev, &ci, nullptr, &v); return v;
}

void Renderer::transitionImg(VkImage img, VkFormat, VkImageLayout from, VkImageLayout to) {
    auto cmd = beginOnce();
    VkImageMemoryBarrier b{VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER};
    b.oldLayout = from; b.newLayout = to;
    b.srcQueueFamilyIndex = b.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    b.image = img; b.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
    VkPipelineStageFlags src, dst;
    if (from == VK_IMAGE_LAYOUT_UNDEFINED) {
        b.srcAccessMask = 0; b.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        src = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; dst = VK_PIPELINE_STAGE_TRANSFER_BIT;
    } else {
        b.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        b.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        src = VK_PIPELINE_STAGE_TRANSFER_BIT; dst = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    }
    vkCmdPipelineBarrier(cmd, src, dst, 0, 0, nullptr, 0, nullptr, 1, &b);
    endOnce(cmd);
}

void Renderer::cpBufToImg(VkBuffer buf, VkImage img, uint32_t w, uint32_t h) {
    auto cmd = beginOnce();
    VkBufferImageCopy r{};
    r.imageSubresource = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 0, 1};
    r.imageExtent = {w, h, 1};
    vkCmdCopyBufferToImage(cmd, buf, img, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &r);
    endOnce(cmd);
}

VkCommandBuffer Renderer::beginOnce() {
    VkCommandBufferAllocateInfo ai{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
    ai.commandPool = m_cp; ai.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; ai.commandBufferCount = 1;
    VkCommandBuffer cmd; vkAllocateCommandBuffers(m_dev, &ai, &cmd);
    VkCommandBufferBeginInfo bi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
    bi.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    vkBeginCommandBuffer(cmd, &bi);
    return cmd;
}

void Renderer::endOnce(VkCommandBuffer cmd) {
    vkEndCommandBuffer(cmd);
    VkSubmitInfo si{VK_STRUCTURE_TYPE_SUBMIT_INFO};
    si.commandBufferCount = 1; si.pCommandBuffers = &cmd;
    vkQueueSubmit(m_gfxQ, 1, &si, VK_NULL_HANDLE);
    vkQueueWaitIdle(m_gfxQ);
    vkFreeCommandBuffers(m_dev, m_cp, 1, &cmd);
}

//filename: ./src/Window.h
#pragma once
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#include <string>
#include <unordered_map>

class Window {
public:
    Window(int w, int h, const std::string& title);
    ~Window();
    Window(const Window&) = delete;
    Window& operator=(const Window&) = delete;

    bool shouldClose() const { return glfwWindowShouldClose(m_window); }
    void poll()              { glfwPollEvents(); }
    void setTitle(const std::string& t) { glfwSetWindowTitle(m_window, t.c_str()); }

    GLFWwindow* handle()  const { return m_window; }
    int         width()   const { return m_w; }
    int         height()  const { return m_h; }
    float       aspect()  const { return m_h > 0 ? float(m_w) / float(m_h) : 1.f; }
    bool        resized() const { return m_resized; }
    void        clearResize()   { m_resized = false; }

private:
    static std::unordered_map<GLFWwindow*, Window*> s_map;
    static void resizeCb(GLFWwindow* w, int width, int height) {
        auto it = s_map.find(w);
        if (it == s_map.end()) return;
        it->second->m_w = width;
        it->second->m_h = height;
        it->second->m_resized = true;
    }

    GLFWwindow* m_window = nullptr;
    int  m_w, m_h;
    bool m_resized = false;
};

//filename: ./src/Types.h
#pragma once
#include <vulkan/vulkan.h>
#include <glm/glm.hpp>
#include <vector>
#include <string>
#include <array>

struct Vertex {
    glm::vec3 pos;
    glm::vec3 normal;
    glm::vec2 uv;

    static VkVertexInputBindingDescription binding() {
        return {0, sizeof(Vertex), VK_VERTEX_INPUT_RATE_VERTEX};
    }

    static std::array<VkVertexInputAttributeDescription, 3> attrs() {
        return {{
            {0, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(Vertex, pos)},
            {1, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(Vertex, normal)},
            {2, 0, VK_FORMAT_R32G32_SFLOAT,    offsetof(Vertex, uv)},
        }};
    }
};

struct alignas(16) UBO {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
    glm::vec4 lightPos;
    glm::vec4 lightColor;
    glm::vec4 viewPos;
    glm::vec2 uvOffset;
    glm::vec2 uvScale;
};

struct MeshData {
    std::vector<Vertex>   vertices;
    std::vector<uint32_t> indices;
    std::string           texturePath;
};

//filename: ./src/Window.cpp
#include "Window.h"
#include <stdexcept>

std::unordered_map<GLFWwindow*, Window*> Window::s_map;

Window::Window(int w, int h, const std::string& title) : m_w(w), m_h(h) {
    if (!glfwInit())
        throw std::runtime_error("glfwInit failed");
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    m_window = glfwCreateWindow(w, h, title.c_str(), nullptr, nullptr);
    if (!m_window) { glfwTerminate(); throw std::runtime_error("glfwCreateWindow failed"); }
    s_map[m_window] = this;
    glfwSetFramebufferSizeCallback(m_window, resizeCb);
}

Window::~Window() {
    s_map.erase(m_window);
    glfwDestroyWindow(m_window);
    glfwTerminate();
}

//filename: ./src/Mesh.h
#pragma once
#include "Types.h"
#include <string>
#include <vector>

std::vector<MeshData> loadOBJ(const std::string& path);

//filename: ./src/Timer.h
#pragma once
#include <chrono>

class Timer {
public:
    using Clock = std::chrono::high_resolution_clock;

    Timer() { reset(); }

    void reset() {
        m_start = m_prev = Clock::now();
        m_dt = m_total = 0.f;
        m_fps = m_frames = 0;
        m_fpsAccum = 0.f;
    }

    void tick() {
        auto now   = Clock::now();
        m_dt       = std::chrono::duration<float>(now - m_prev).count();
        m_total    = std::chrono::duration<float>(now - m_start).count();
        m_prev     = now;
        if (m_dt > 0.1f) m_dt = 0.1f;
        m_fpsAccum += m_dt;
        m_frames++;
        if (m_fpsAccum >= 1.f) {
            m_fps      = m_frames;
            m_frames   = 0;
            m_fpsAccum -= 1.f;
        }
    }

    float dt()    const { return m_dt;    }
    float total() const { return m_total; }
    int   fps()   const { return m_fps;   }

private:
    Clock::time_point m_start, m_prev;
    float m_dt, m_total, m_fpsAccum;
    int   m_fps, m_frames;
};

//filename: ./src/Input.h
#pragma once
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <unordered_map>

class Input {
public:
    static Input& get() { static Input i; return i; }
    Input(const Input&) = delete;
    Input& operator=(const Input&) = delete;

    void init(GLFWwindow* window) {
        m_window = window;
        glfwSetWindowUserPointer(window, this);
        glfwSetKeyCallback(window, keyCb);
        glfwSetCursorPosCallback(window, cursorCb);
        glfwSetMouseButtonCallback(window, mouseBtnCb);
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        if (glfwRawMouseMotionSupported())
            glfwSetInputMode(window, GLFW_RAW_MOUSE_MOTION, GLFW_TRUE);
    }

    void beginFrame() {
        m_justPressed.clear();
        m_delta = {};
    }

    bool isDown(int key)    const { auto it = m_keys.find(key);    return it != m_keys.end()    && it->second; }
    bool pressed(int key)   const { auto it = m_justPressed.find(key); return it != m_justPressed.end() && it->second; }
    bool mouseDown(int btn) const { auto it = m_mouse.find(btn);   return it != m_mouse.end()   && it->second; }

    glm::vec2 delta() const { return m_delta; }

private:
    Input() = default;

    static void keyCb(GLFWwindow* w, int key, int, int action, int) {
        auto* s = static_cast<Input*>(glfwGetWindowUserPointer(w));
        s->m_keys[key] = (action != GLFW_RELEASE);
        if (action == GLFW_PRESS) s->m_justPressed[key] = true;
    }

    static void cursorCb(GLFWwindow* w, double x, double y) {
        auto* s = static_cast<Input*>(glfwGetWindowUserPointer(w));
        glm::vec2 pos(x, y);
        if (s->m_firstMove) { s->m_prev = pos; s->m_firstMove = false; }
        s->m_delta += pos - s->m_prev;
        s->m_prev   = pos;
    }

    static void mouseBtnCb(GLFWwindow* w, int btn, int action, int) {
        auto* s = static_cast<Input*>(glfwGetWindowUserPointer(w));
        s->m_mouse[btn] = (action == GLFW_PRESS);
    }

    GLFWwindow* m_window = nullptr;
    std::unordered_map<int, bool> m_keys, m_justPressed, m_mouse;
    glm::vec2 m_delta{}, m_prev{};
    bool m_firstMove = true;
};

//filename: ./shaders/phong.vert
#version 450

layout(location = 0) in vec3 inPos;
layout(location = 1) in vec3 inNormal;
layout(location = 2) in vec2 inUV;

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
    vec4 lightPos;
    vec4 lightColor;
    vec4 viewPos;
    vec2 uvOffset;
    vec2 uvScale;
} ubo;

layout(location = 0) out vec3 fragWorldPos;
layout(location = 1) out vec3 fragNormal;
layout(location = 2) out vec2 fragUV;

void main() {
    vec4 worldPos   = ubo.model * vec4(inPos, 1.0);
    fragWorldPos    = worldPos.xyz;

    mat3 normalMat  = transpose(inverse(mat3(ubo.model)));
    fragNormal      = normalize(normalMat * inNormal);

    fragUV = inUV * ubo.uvScale + ubo.uvOffset;

    gl_Position = ubo.proj * ubo.view * worldPos;
}

//filename: ./shaders/phong.frag
#version 450

layout(location = 0) in vec3 fragWorldPos;
layout(location = 1) in vec3 fragNormal;
layout(location = 2) in vec2 fragUV;

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
    vec4 lightPos;
    vec4 lightColor;
    vec4 viewPos;
    vec2 uvOffset;
    vec2 uvScale;
} ubo;

layout(binding = 1) uniform sampler2D texSampler;

layout(location = 0) out vec4 outColor;

void main() {
    vec3 texColor   = texture(texSampler, fragUV).rgb;
    vec3 lightColor = ubo.lightColor.rgb;
    float specPow   = max(ubo.lightColor.w, 1.0);

    vec3 N = normalize(fragNormal);
    vec3 L = normalize(ubo.lightPos.xyz - fragWorldPos);
    vec3 V = normalize(ubo.viewPos.xyz  - fragWorldPos);
    vec3 R = reflect(-L, N);

    vec3 ambient  = 0.15 * lightColor * texColor;
    vec3 diffuse  = max(dot(N, L), 0.0) * lightColor * texColor;
    float spec    = pow(max(dot(V, R), 0.0), specPow);
    vec3 specular = 0.5 * spec * lightColor;

    outColor = vec4(ambient + diffuse + specular, 1.0);
}

